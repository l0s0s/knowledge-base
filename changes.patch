diff --git a/knowledge_base/middleware/prefix.py b/knowledge_base/middleware/prefix.py
index e050371..52bab1f 100644
--- a/knowledge_base/middleware/prefix.py
+++ b/knowledge_base/middleware/prefix.py
@@ -8,12 +8,16 @@ When nginx sends "X-Script-Name: /api/knowledge" header:
 - Strips the prefix from request.path_info so Django routes work normally
 - Sets request.META['SCRIPT_NAME'] so Django generates correct URLs with the prefix
 
+If X-Script-Name header is not present, uses FORCE_SCRIPT_NAME from settings as fallback.
+
 This ensures:
 - Django routes don't need "/api/knowledge" prefix internally
 - Django-generated URLs (redirects, static files, etc.) include "/api/knowledge" prefix
-- Works transparently behind reverse proxy
+- Works transparently behind reverse proxy or directly
 """
 
+from django.conf import settings
+
 
 class PrefixMiddleware:
     """
@@ -32,9 +36,14 @@ class PrefixMiddleware:
     def __call__(self, request):
         # Get the script name prefix from X-Script-Name header (sent by nginx)
         # Example: nginx sends "X-Script-Name: /api/knowledge"
+        # If header is not present, use FORCE_SCRIPT_NAME from settings as fallback
         original_path_info = request.path_info
         original_script_name_header = request.META.get('HTTP_X_SCRIPT_NAME', '')
-        script_name = original_script_name_header.rstrip('/')
+        script_name = original_script_name_header.rstrip('/') if original_script_name_header else ''
+        
+        # If no header, use FORCE_SCRIPT_NAME from settings as fallback
+        if not script_name:
+            script_name = getattr(settings, 'FORCE_SCRIPT_NAME', '').rstrip('/')
         
         # Логирование для отладки
         print("\n" + "-"*80)
@@ -42,12 +51,15 @@ class PrefixMiddleware:
         print("-"*80)
         print(f"Original path_info: {original_path_info}")
         print(f"HTTP_X_SCRIPT_NAME header: {original_script_name_header}")
+        print(f"FORCE_SCRIPT_NAME from settings: {getattr(settings, 'FORCE_SCRIPT_NAME', 'NOT SET')}")
         print(f"Extracted script_name: {script_name}")
         
         if script_name:
             # Remove the prefix from path_info so Django routes work normally
             # Example: "/api/knowledge/admin/" becomes "/admin/" internally
-            # Example: "/api/knowledge/knowledge/docs/" becomes "/knowledge/docs/" internally
+            # But only if path_info actually starts with the prefix
+            # Note: When nginx proxies, path_info may already have the prefix stripped
+            # or it may still contain it, depending on nginx configuration
             if request.path_info.startswith(script_name):
                 request.path_info = request.path_info[len(script_name):]
                 # Ensure path_info starts with "/" (handle case where script_name was the entire path)
@@ -55,15 +67,16 @@ class PrefixMiddleware:
                     request.path_info = '/' + request.path_info
                 print(f"Stripped prefix: path_info changed from '{original_path_info}' to '{request.path_info}'")
             else:
-                print(f"WARNING: path_info '{request.path_info}' does not start with script_name '{script_name}'")
+                # Path doesn't start with prefix - this is OK if nginx already stripped it
+                print(f"Path '{request.path_info}' does not start with script_name '{script_name}' - assuming nginx already stripped it")
             
-            # Set SCRIPT_NAME in META so Django's URL generation includes the prefix
+            # Always set SCRIPT_NAME in META so Django's URL generation includes the prefix
             # This ensures redirects, static URLs, etc. are generated correctly with "/api/knowledge" prefix
             request.META['SCRIPT_NAME'] = script_name
             print(f"Set SCRIPT_NAME in META: {script_name}")
         else:
-            print("WARNING: No HTTP_X_SCRIPT_NAME header found! PrefixMiddleware will not modify request.")
-            print("This is normal if accessing Django directly (not through nginx).")
+            print("WARNING: No HTTP_X_SCRIPT_NAME header found and FORCE_SCRIPT_NAME not set!")
+            print("PrefixMiddleware will not modify request.")
         
         print(f"Final path_info: {request.path_info}")
         print(f"Final SCRIPT_NAME: {request.META.get('SCRIPT_NAME', 'NOT SET')}")
